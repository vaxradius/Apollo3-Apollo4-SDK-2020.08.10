Name:
=====
 adc_lpmode0_dma


Description:
============
 This example takes samples with the ADC at high-speed using DMA.


Purpose:
========
This example shows the CTIMER-A3 triggering repeated samples of an external
input at 1.2Msps in LPMODE0.  The example uses the CTIMER-A3 to trigger
ADC sampling.  Each data point is 128 sample average and is transferred
from the ADC FIFO into an SRAM buffer using DMA.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 adc_lpmode2


Description:
============
 This example takes samples with the ADC at 1Hz in lowest power mode.


Purpose:
========
To demonstrate the lowest possible power usage of the ADC.  The
example powers off the ADC between samples.  CTIMER-A1 is used to drive the
process.  The CTIMER ISR reconfigures the ADC from scratch and triggers each
sample.  The ADC ISR stores the sample and shuts down the ADC.

Additional Information:
=======================
The ADC_EXAMPLE_DEBUG flag is used to display information in the example to
show that it is operating.  This should be set to 0 for true low power
operation.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 adc_vbatt


Description:
============
 Example of ADC sampling VBATT voltage divider, BATT load, and temperature.


Purpose:
========
This example initializes the ADC, and a timer. Two times per second it
reads the VBATT voltage divider and temperature sensor and prints them.
It monitors button 0 and if pressed, it turns on the BATT LOAD resistor.
One should monitor MCU current to see when the load is on or off.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 apollo3_secbl


Description:
============
 A simple secondary bootloader program example for Apollo3


Purpose:
========
This program is an example template for a secondary bootloader program for Apollo3.
It demonstrates how to access info0 key area. It demonstrates how to use the Ambiq SBL OTA 
framework for customer specific OTAs, e.g. to support external flash, or to support more 
advanced auth/enc schemes. It demonstrates how to validate & transfer control to the real 
main program image (assumed to be at address specified by MAIN_PROGRAM_ADDR_IN_FLASH in flash)
after locking the info0 area before exiting

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
To exercise this program:
Flash the main program at 0x10000 (MAIN_PROGRAM_ADDR_IN_FLASH)
Link this program at the address suitable for SBL nonsecure (0xC000) or secure (0xC100)
configuration
To test OTA - construct images using magic numbers in the range matching
AM_IMAGE_MAGIC_CUST
To test INFO0 key area access - need to keep INFO0->Security->PLONEXIT as 0



******************************************************************************


Name:
=====
 b0_hfadj


Description:
============
 B0 HFADJ (ERR00x) SW Workaround Example.


Purpose:
========
This example demonstrates how to update a customer application to
workaround ERR00x.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 binary_counter


Description:
============
 Example that displays the timer count on the LEDs.


Purpose:
========
This example increments a variable on every timer interrupt. The global
variable is used to set the state of the LEDs. The example sleeps otherwise.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_amdtpc


Description:
============
 ARM Cordio BLE - AMDTP Client (Master) Example.


Purpose:
========
This example is the client (master) for the BLE Ambiq Micro
Data Transfer Protocol.  This example is meant to run on an Apollo3 EVB
along with another Apollo3 EVB serving as the server. This example provides 
a UART command line interface with a simple menu that allows the user to scan, 
connect and initiate data transfers from either M->S or S->M direction.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_amdtps


Description:
============
 ARM Cordio BLE - AMDTP Server (Slave) Example.


Purpose:
========
This example is the server (slave) for the BLE Ambiq Micro
Data Transfer Protocol.  This example is meant to run on an Apollo3 EVB
along with another Apollo3 EVB serving as the client.  This example waits
for connection and initiation of data transfers by the client (master).

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_amota


Description:
============
 ARM Cordio BLE - Ambiq Micro Over the Air (AMOTA) Example.


Purpose:
========
This example implements Ambiq Micro Over-the-Air (OTA) slave.  This
example is designed to allow loading of a binary software update from either
and iOS or Android phone running Ambiq's application.  This example works
with the Apollo3 Secure Bootloader (SBL) to place the image in flash and then
reset the Apollo3 to allow SBL to validate and install the image.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

If enabled, debug messages will be sent over ITM at 1M Baud.

Additional Information:
=======================
The directory \tools\apollo3_amota\scripts contains a Makefile which will
build the OTA binary.

The directory \docs\app_notes\amota explains how to use the Ambiq iOS and
Android applications.


******************************************************************************


Name:
=====
 ble_freertos_ancs


Description:
============
 ARM Cordio BLE - Apple Notification Center Service (ANCS) Example.


Purpose:
========
This example implements a BLE Apple Notification Center Service
profile.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_barebone


Description:
============
 Example of the ble_freertos_barebone app running under FreeRTOS.


This example implements a BLE barebone proejct within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the non-"lp" version of this example enables
them by default).  To enable debug printing, add the following project-level
macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_beaconscanner


Description:
============
 ARM Cordio BLE - Beaconscanner Application Example.


Purpose:
========
This example implements a BLE beacon scanner within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the non-"lp" version of this example enables
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_eddystone_url


Description:
============
 ARM Cordio BLE - eddystone_url Example


Purpose:
========
This is a standard BLE eddystone_url example.

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.



******************************************************************************


Name:
=====
 ble_freertos_fit


Description:
============
 ARM Cordio BLE - Fit Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_fit_lp


Description:
============
 ARM Cordio BLE - Fit Application Example at lowest possible power.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the non-"lp" version of this example enables
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_hid


Description:
============
 Example of the hid app running under FreeRTOS.


This example implements a BLE heart rate sensor within the FreeRTOS
framework. To save power, this application is compiled without print
statements by default. To enable them, add the following project-level
macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 ble_freertos_power_cycle


Description:
============
 ARM Cordio BLE - Power Cycling Apollo3 BLE Controller Example


Purpose:
========
This example demonstrates how to properly shutdown and restart the
BLE Controller in an operational system.  This includes the steps to restart
the ARM Cordio Host Stack in order to resynchronize with the BLE Controller.
The shutdown/restart process is driven by a 10 second WSF (Cordio) timer.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_tag


Description:
============
 ARM Cordio BLE - Proximity Tag Example


Purpose:
========
This is a standard BLE Proximity Profile example.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_throughput


Description:
============
 ARM Cordio BLE - Ambiq Micro Throughput Example.


Purpose:
========
This example implements is based on Over-the-Air (OTA) example,
is designed to test the data transmitting thourghput.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

If enabled, debug messages will be sent over ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_txpower_ctrl


Description:
============
 ARM Cordio BLE - Transmit Power Control Example


Purpose:
========
This example demonstrates the control of BLE TX power level based
on pressing Button #0 on the Apollo3 EVB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_watch


Description:
============
 ARM Cordio BLE - Concurrent Master/Slave Example.


Purpose:
========
This example demonstrates an BLE application in the Central role.
That is the BLE application operates as a slave to phone master and as the
master of subordinate slave devices running freertos_fit example in this SDK.

Additional Information:
=======================
1. Printing takes place over the ITM at 1M Baud.
2. When the example powers up, 
2.A. it enters advertising mode by default to wait for connection from 
smart phone with Time profile, Alert Notification profile and Phone
Alert Status profile supported.
2.B. when BTN2 on Apollo3 EVB is short-pressed, if advertising is on, it
stops advertising first and then starts scanning when advertising is
stopped; if scanning is on, it stops scanning and re-start advertising
when scanning stops.
2.C. During scanning, the device (if discovered) running freertos_fit
example in this SDK will be connected and scanning will be stopped.
2.D. Repeat 2.B. and 2.C. above to connect to a new slave device running 
freertos_fit example (max slaves is 3).
3. when phone (iPhone is used) connects to this example, the services of Time
profile, Alert Notification profile and Phone Alert Status profile will be


******************************************************************************


Name:
=====
 turbomode


Description:
============
 Example demonstrates the usage of TurboSPOT (aka burst mode) HAL.


Purpose:
========
This example shows how to detect if TurboSPOT Mode is available.
If so, it sets the Apollo3 into Normal (48MHz) mode, then times a
calculation of prime numbers, displaying the elapsed time.  Next, it
switches the Apollo3 into Burst mode, performs the same calculation, then
displays the elapsed time, which should be roughly 50% of Normal mode.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 cache_monitor


Description:
============
 Example to show the performance of cache.


Purpose:
========
This example provides a demonstration of the cache monitor to check
the cache hit rate and cache miss number.

Additional Information:
=======================
If the fireball device card is used, this example can work on:
Apollo3p_evb + Cygnus
Recommend to use 3.3V power supply voltage.



******************************************************************************


Name:
=====
 coremark


Description:
============
 EEMBC COREMARK test.


Purpose:
========
This example runs the official EEMBC COREMARK test.

The Coremark run begins by first outputing a banner (to the UART)
indicating that it has started.  It then does a complete disable
and power down of the UART for accurate power measuring during the run.

The Coremkark implementation performs 2000 ITERATIONS (specified in
ambiq_core_config.h), which is plenty of time for correct operation
of the benchmark.

Once the run has completed, the UART is reenabled and the results printed.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 ctimer_multi_bidirectional_stepper


Description:
============
 CTimer multiple bidirectional stepper motors Example,


Purpose:
========
This example demonstrates how to create arbitrary patterns on multiple
CTimers.  TMR6 A is used to create base timing for the patterns.  TMR0 B
TMR1 A and TMR1 B are configured to dual edge trigger on TMR6 with separate
counting patterns. All timers are configured to run and then synchronized
off of the global timer enable.  

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
The patterns are output as follows:
Pin12 - TMR6 A dual edge trigger pulse
Pin13 - TMR0 B positive pattern
Pin18   TMR1 A negative pattern
Pin19   TMR1 B inactive pattern


******************************************************************************


Name:
=====
 ctimer_pwm_output


Description:
============
 Breathing LED example.


Purpose:
========
This example shows one way to vary the brightness of an LED using a timer
in PWM mode.  The timer can be clocked from either the XTAL (default) or
the LFRC, selectable by a define, USE_XTAL.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ctimer_repeated_pattern


Description:
============
 CTimer Repeated Pattern Example


Purpose:
========
This example demonstrates how to create arbitrary repeated pattern on
CTimer.  TMR0 A is used to create base timing for the pattern.  TMR0 B
is configured to terminated on TMR0. All timers are configured to run and 
then synchronized off of the global timer enable.  

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
The patterns are output as follows:
Pin12 - TMR0 A terminate pulse
Pin13 - TMR0 B pattern



******************************************************************************


Name:
=====
 ctimer_stepper_synch_32bit_pattern


Description:
============
 CTimer Stepper Motor Synchronized 32 bit Pattern Example


Purpose:
========
This example demonstrates how to create arbitrary patterns on multiple
CTimers.  TMR0 A is used to create base timing for the patterns.  TMR0 B
and TMR1 A/B are configured to trigger on TMR0 with separate counting 
patterns.  All timers are configured to run and then synchronized off of 
the global timer enable.  

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
The patterns are output as follows:
Pin12 - TMR0 A trigger pulse
Pin13 - TMR0 B pattern1
Pin18 - TMR1 A pattern2
Pin19 - TMR1 B pattern3



******************************************************************************


Name:
=====
 ctimer_stepper_synch_64bit_pattern


Description:
============
 CTimer Stepper Motor Synchronized 64 bit Pattern Example


Purpose:
========
This example demonstrates how to create arbitrary patterns on
CTimer.  TMR0 A is used to create base timing for the pattern.
and TMR1 A is configured to trigger on TMR0.
All timers are configured to run and then synchronized off of 
the global timer enable.  

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
The patterns are output as follows:
Pin12 - TMR0 A trigger pulse
Pin18 - TMR1 A pattern



******************************************************************************


Name:
=====
 deepsleep


Description:
============
 Example demonstrating how to enter deepsleep.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
sleep mode the device has no ability to wake up. This example is merely to
provide the opportunity to measure deepsleep current without interrupts
interfering with the measurement.

The example begins by printing out a banner announcement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep_wake


Description:
============
 Example that goes to deepsleep and wakes from either the RTC or GPIO.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
deep sleep the RTC peripheral will wake the device every second, check to
see if 5 seconds has elapsed and then toggle LED1.

Alternatively, it will awake when button 0 is pressed and toggle LED0.

The example begins by printing out a banner annoucement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 fast_gpio


Description:
============
 Example that demonstrates how to use the Fast GPIO feature of Apollo3.


Purpose:
========
This example demonstrates how to use Fast GPIO on Apollo3.  The example
updates the LEDs with waveforms that can be observed with a logic analyzer.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 flash_selftest


Description:
============
 An example to test all onboard flash.


Purpose:
This example runs a series of test patterns on all instances of the device
flash.  It performs many of the same tests that the hardware BIST (built
in self test) uses at production test.

Results are saved in coded form to a defined data word (g_result) which
tracks any failure.  Further, g_result can be given an absolute address
location so that an outside system will know where to find the results.

Results output is also configurable such that the simplified results
(pass/fail, done, etc.) can be output to GPIO bits.

The test must be loaded and executed in SRAM.  Therefore a J-Link Commander
batch file is provided here to assist with that.
Alternatively the program can be loaded with a debugger and run from there.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
Using the J-Link Commander batch file on an Apollo3 Blue EVB:
- The Commander script file is one of either selftest_commander_gcc.jlink,
selftest_commander_iar.jlink, or selftest_commander_keil.jlink.
- Requires Segger J-Link v6.60 or later.
- As shipped in the SDK, the J-Link Commander scripts should be correctly
configured to run the given binary. If the test is modified, the commander
script may need an update of the SP and PC.  The first two word values in
the vector table of your compiled binary determine the required values.
- Use the following command line at a DOS prompt.
jlink -CommanderScript selftest_commander_xxx.jlink
- The flash self test stores results to address 0x10030000.
0xFAE00000 = Pass, the flash tested good.
0xFAE0xxxx = Fail, where xxxx is a failure code.
- If USE_TIMER is enabled, the run time of the selftest is stored in two
words at 0x10030004 and 0x1003008.  The first word is the whole number
of seconds, the second is the fractional part to 3 decimals.  Therefore
the two values show the total run time in the form:  ss.fff



******************************************************************************


Name:
=====
 flash_write


Description:
============
 Flash write example.


Purpose:
========
This example shows how to modify the internal Flash using HAL flash helper
functions.

This example works on instance 1 of the Flash, i.e. the portion of the
Flash above 256KB/512KB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 freertos_lowpower


Description:
============
 Example of the app running under FreeRTOS.


This example implements LED task within the FreeRTOS framework. It monitors
three On-board buttons, and toggles respective on-board LEDs in response.
To save power, this application is compiled without print
statements by default. To enable them, add the following project-level
macro definitions.

AM_DEBUG_PRINTF

If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 hello_fault


Description:
============
 A simple example that causes a hard-fault.


Purpose:
========
This example demonstrates the extended hard fault handler which can
assist the user in decoding a fault condition. The handler pulls the
registers that the Cortex M4 automatically loads onto the stack and
combines them with various other fault information into a single
data structure saved locally.  It can optionally print out the fault
data structure (assuming the stdio printf has previously been enabled
and is still enabled at the time of the fault).

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 hello_world


Description:
============
 A simple "Hello World" example.


Purpose:
========
This example prints a "Hello World" message with some device info.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 hello_world_uart


Description:
============
 A simple "Hello World" example using the UART peripheral.


Purpose:
========
This example prints a "Hello World" message with some device info
over UART at 115200 baud. To see the output of this program, run AMFlash,
and configure the console for UART. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 ios_fifo


Description:
============
 Example slave used for demonstrating the use of the IOS FIFO.


Purpose:
========
This slave component runs on one EVB and is used in conjunction with
the companion host example, ios_fifo_host, which runs on a second EVB.

The ios_fifo example has no print output.
The host example does use the ITM SWO to let the user know progress and
status of the demonstration.

This example implements the slave part of a protocol for data exchange with
an Apollo IO Master (IOM).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgment to IOS once it has finished reading a block
of data initiated by IOS (partially or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
In order to run this example, a host device (e.g. a second EVB) must be set
up to run the host example, ios_fifo_host.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[7]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[6]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 ios_fifo_host


Description:
============
 Example host used for demonstrating the use of the IOS FIFO.


Purpose:
========
This host component runs on one EVB and is used in conjunction with
the companion slave example, ios_fifo, which runs on a second EVB.

The host example uses the ITM SWO to let the user know progress and
status of the demonstration.  The SWO is configured at 1M baud.
The ios_fifo example has no print output.

This example implements the host part of a protocol for data exchange with
an Apollo IO Slave (IOS).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgement to IOS once it has finished reading a block
of data initiated by IOS (partitally or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Additional Information:
=======================
In order to run this example, a slave device (e.g. a second EVB) must be set
up to run the companion example, ios_fifo.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[7]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[6]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 ios_lram


Description:
============
 Example slave used for demonstrating the use of the IOS lram.


Purpose:
========
This slave component runs on one EVB and is used in conjunction with
the companion host example, ios_lram_host, which runs on a second EVB.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
In order to run this example, a host device (e.g. a second EVB) must be set
up to run the host example, ios_lram_host.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_lram_host)                    SLAVE (ios_lram)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[7]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[6]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_lram_host)                    SLAVE (ios_lram)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 ios_lram_host


Description:
============
 Example host used for demonstrating the use of the IOS LRAM.


Purpose:
========
This host component runs on one EVB and is used in conjunction with
the companion slave example, ios_lram, which runs on a second EVB.

The host example uses the ITM SWO to let the user know progress and
status of the demonstration.  The SWO is configured at 1M baud.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
In order to run this example, a slave device (e.g. a second EVB) must be set
up to run the companion example, ios_lram.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_lram_host)                    SLAVE (ios_lram)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[7]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[6]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_lram_host)                    SLAVE (ios_lram)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 mspi_octal_example


Description:
============
 Example of the MSPI operation with Octal SPI Flash.


Purpose:
========
This example configures an MSPI connected flash device in Octal mode
and performs various operations - verifying the correctness of the same
Operations include - Erase, Write, Read, and XIP

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
this example can work on:
Apollo3p_evb + Cygnus
Target hardware uses 1.8V power supply voltage.
Actual Octal flash on Cygnus board is ATXP128 (Device ID: 0x00A91F) instead of ATXP032
Define ADESTO_ATXP032



******************************************************************************


Name:
=====
 pdm_fft


Description:
============
 An example to show basic PDM operation.


Purpose:
========
This example enables the PDM interface to record audio signals from an
external microphone. The required pin connections are:

Printing takes place over the ITM at 1M Baud.

GPIO 11 - PDM DATA
GPIO 12 - PDM CLK


******************************************************************************


Name:
=====
 prime


Description:
============
 Example that displays the timer count on the LEDs.


Purpose:
========
This example consists of a non-optimized, brute-force routine for computing
the number of prime numbers between 1 and a given value, N. The routine
uses modulo operations to determine whether a value is prime or not. While
obviously not optimal, it is very useful for exercising the core.

For this example, N is 100000, for which the answer is 9592.

For Apollo3 at 48MHz, the time to compute the answer for Keil and IAR:
IAR v8.11.1:        1:43.
Keil ARMCC 4060528: 1:55.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
The goal of this example is to measure current consumption while the core
is working to compute the answer. Power and energy can then be derived
knowing the current and run time.

The example prints an initial banner to the UART port.  After each prime
loop, it enables the UART long enough to print the answer, disables the
UART and starts the computation again.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.

Note: For minimum power, disable the printing by setting PRINT_UART to 0.

The prime_number() routine is open source and is used here under the
GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007.  Details,
documentation, and the full license for this routine can be found in
the third_party/prime_mpi/ directory of the SDK.



******************************************************************************


Name:
=====
 reset_states


Description:
============
 Example of various reset options in Apollo.


Purpose:
========
This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.

The program will repeat the following sequence on the console:
(POI Reset) 5 Interrupts - (WDT Reset) 3 Interrupts - (POR Reset) 3 Interrupts

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 rtc_print


Description:
============
 Example using the internal RTC.


This example demonstrates how to interface with the RTC and prints the
time over SWO.

The example works by configuring a timer interrupt which will periodically
wake the core from deep sleep. After every interrupt, it prints the current
RTC time.



******************************************************************************


Name:
=====
 stimer


Description:
============
 Example using a stimer with interrupts.


Purpose:
========
This example demonstrates how to setup the stimer for counting and
interrupts. It toggles LED 0 to 4 every interrupt, which is set for 1 sec.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 uart_ble_bridge


Description:
============
 Converts UART HCI commands to SPI.


Purpose:
========
 This example is primarily designed to enable DTM testing with the
Apollo3 EVB. The example accepts HCI commands over the UART at 115200 baud
and sends them using the BLEIF to the Apollo3 BLE Controller.  Responses from
the BLE Controller are accepted over the BLEIF and sent over the UART.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 uart_boot_host


Description:
============
 Converts UART Wired transfer commands to SPI for use with SBL SPI testing.


Purpose:
========
This example running on an intermediate board, along with the standard
uart_wired_update script running on host PC, can be used as a way to
communicate to Apollo3 SBL using SPI mode.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
PIN fly lead connections assumed:
HOST (this board)                       SLAVE (Apollo3 SBL target)
--------                                --------
Apollo3 SPI or I2C common connections:
GPIO[2]  GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[4]  OVERRIDE pin   (host to slave) GPIO[16] Override pin or n/c
GPIO[17] Slave reset (host to slave)    Reset Pin or n/c
GND                                     GND

Apollo3 SPI additional connections:
GPIO[5]  IOM0 SPI CLK                   GPIO[0]  IOS SPI SCK
GPIO[6]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[7]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE

Apollo3 I2C additional connections:
GPIO[5]  I2C SCL                        GPIO[0]  I2C SCL
GPIO[6]  I2C SDA                        GPIO[1]  I2C SDA

Reset and Override pin connections from Host are optional, but using them
automates the entire process.

SPI or I2C mode can be handled in a couple of ways:
- SPI mode is the default (i.e. don't press buttons or tie pins low).
- For I2C, press button2 during reset and hold it until the program begins,
i.e. you see the "I2C clock = " msg.
Alternatively the button2 pin can be tied low.
- Note that on the Apollo3 EVB, button2 is labelled as 'BTN4', which is
the button located nearest the end of the board.
Also on the Apollo3 EVB, BTN4 uses pin 19.  It happens that the header
pin for pin 19 on the EVB is adjacent to a ground pin, so a jumper can
be used to assert I2C mode.



******************************************************************************


Name:
=====
 watchdog


Description:
============
 Example of a basic configuration of the watchdog.


Purpose:
========
This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 while


Description:
============
 Example to emulate a polling loop.


Purpose:
========
This example provides a demonstration of the power required while
executing in a tight loop on the Apollo3 MCU.



******************************************************************************


Name:
=====
 pdm_rtt_stream


Description:
============
 An example to show PDM audio streaming to PC over RTT data logger.


Purpose:
========
This example enables the PDM interface to record audio signals from an
external microphone. The required pin connections are:

Printing takes place over the ITM at 1M Baud.
RTT logger takes place over the SWD at 4M Baud.

Usage:
======
Build and download the program into the target device.
Reset the target and check the SWO print for PDM settings.
Run the helper script 'rtt_logger.py' in the project folder

python3 rtt_logger.py

(In this example, RTT control block is mapped to a fixed address to facilitate
the searching process. If the address is changed, make sure to modify
the rtt_logger.py script to match the address.)

During data streaming, press any key to stop the recording.
The audio captured is stored into the same folder as the rtt_logger.py,
with a file name of yyyymmdd-hh-mm-ss.pcm.

To check the audio, load the *.pcm file into audio analysis tools and check.
E.g. in Audacity, https://www.audacityteam.org/:
File -> Import -> Raw data...
Default import format is:
Signed 24-bit PCM
Little-endian
2 Channels (Stereo)
Start offset: 0 bytes
Amount to import: 100%
Sample rate: 16000 Hz


GPIO 50 - PDM0 CLK
GPIO 51 - PDM0 DATA

GPIO 52 - PDM0 CLK
GPIO 53 - PDM0 DATA

GPIO 54 - PDM0 CLK
GPIO 55 - PDM0 DATA

GPIO 56 - PDM0 CLK
GPIO 57 - PDM0 DATA



******************************************************************************


Name:
=====
 ble_freertos_amdtpc


Description:
============
 ARM Cordio BLE - AMDTP Client (Master) Example.


Purpose:
========
This example is the client (master) for the BLE Ambiq Micro
Data Transfer Protocol.  This example is meant to run on an Apollo3 EVB
along with another Apollo3 EVB serving as the server. This example provides
a UART command line interface with a simple menu that allows the user to scan,
connect and initiate data transfers from either M->S or S->M direction.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_ancs


Description:
============
 ARM Cordio BLE - Apple Notification Center Service (ANCS) Example.


Purpose:
========
This example implements a BLE Apple Notification Center Service
profile.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_atps


Description:
============
 ARM Cordio BLE - ATP Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_fcc_test


Description:
============
 ARM Cordio BLE - FCC test example


Purpose:
========
This example is used to put Bluetooth radio in Apollo3 into various
test mode on different channels on pressing BTN3 on the Apollo3 EVB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_fit


Description:
============
 ARM Cordio BLE - Fit Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_locator


Description:
============
 ARM Cordio BLE - Locator Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_throughput


Description:
============
 ARM Cordio BLE - Ambiq Micro Throughput Example.


Purpose:
========
This example implements is based on Over-the-Air (OTA) example,
is designed to test the data transmitting thourghput.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

If enabled, debug messages will be sent over ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_txpower_ctrl


Description:
============
 ARM Cordio BLE - Transmit Power Control Example


Purpose:
========
This example demonstrates the control of BLE TX power level based
on pressing Button #0 on the Apollo3 EVB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_watch


Description:
============
 ARM Cordio BLE - Concurrent Master/Slave Example.


Purpose:
========
This example demonstrates an BLE application in the Central role.
That is the BLE application operates as a slave to phone master and as the
master of subordinate slave devices running freertos_fit example in this SDK.

Additional Information:
=======================
1. Printing takes place over the ITM at 1M Baud.
2. When the example powers up, 
2.A. it enters advertising mode by default to wait for connection from 
smart phone with Time profile, Alert Notification profile and Phone
Alert Status profile supported.
2.B. when BTN2 on Apollo3 EVB is short-pressed, if advertising is on, it
stops advertising first and then starts scanning when advertising is
stopped; if scanning is on, it stops scanning and re-start advertising
when scanning stops.
2.C. During scanning, the device (if discovered) running freertos_fit
example in this SDK will be connected and scanning will be stopped.
2.D. Repeat 2.B. and 2.C. above to connect to a new slave device running 
freertos_fit example (max slaves is 3).
3. when phone (iPhone is used) connects to this example, the services of Time
profile, Alert Notification profile and Phone Alert Status profile will be


******************************************************************************


Name:
=====
 uart_ble_bridge


Description:
============
 Converts UART HCI commands to SPI.


This exapmle can be used as a way to communicate between a host chip using
UART HCI and the BLE module inside Apollo3.


******************************************************************************


Name:
=====
 nemadc_4layer


Description:
============
 NemaDC example.


This example demonstrates DC 4 layers overlay with global alpha blending.
* Layer0 - Red image
* Layer1 - Green image
* Layer2 - Blue image
* Layer3 - Yellow image
Global alpha value can be changed in layer*.alpha. Blendmode can be changed
in layer*.blendmode.

This example can work at two different SPI interfaces. When defined ENABLE_SPI4
in preprocessor defined symbols, this example drives panel through SPI4 interface.
When defined ENABLE_QSPI in preprocessor defined symbols, this example drives
panel through QSPI interface.


******************************************************************************


Name:
=====
 nemadc_dspi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive display panel with 1P1T 2-wire 
Dual-SPI interface.

1P1T 2-wire Dual-SPI interface includes 4 signals, 
* Chip select (CSX)
* SPI clock (CLK)
* Data interface 0 (DATA0)
* Data interface 1 (DATA1).

During the write sequence the display controller writes one or more bytes of 
information to the display module via the interface. The write sequence is 
initiated when CSX is driven from high to low and ends when CSX is pulled high.
Dual-SPI reuses SPI4 DCX as the second DATA signal (DATA1), and sends 4 data
bits per clock cycle. In this example, when send commands, SPI interface works
at SPI4 mode. When send frame data, SPI interface works at Dual-SPI mode. Panel
must be set to Dual-SPI mode through writing register in panel driver IC before
sending frame data.

When define TESTMODE_EN to 1 in nemadc_dspi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemadc_qspi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive display panel with Quad-SPI interface.

Quad-SPI interface includes 6 signals, 
* Chip select (CSX)
* SPI clock (CLK)
* Data interface 0 (DATA0)
* Data interface 1 (DATA1).
* Data interface 2 (DATA2).
* Data interface 3 (DATA3).

Quad-SPI adds two more I/O lines (DATA2 and DATA3) and sends 4 data bits per
clock cycle. During the write sequence the display controller writes one or
more bytes of information to the display module via the interface. The write
sequence is initiated when CSX is driven from high to low and ends when CSX
is pulled high. In this example, when send commands, SPI interface works at
SPI4 mode. When send frame data, SPI interface works at Qual-SPI mode. Panel
must be set to Quad-SPI mode through configuring related pins to correct H/L
level.

When define TESTMODE_EN to 1 in nemadc_qspi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemadc_spi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive a SPI4 panel.

4-wire SPI includes 4 signals, 
* Chip select (CSX)
* SPI clock (CLK)
* SPI bidirectional data interface (DATA)
* Data and command switch (DCX).

During the write sequence the display controller writes one or more bytes of 
information to the display module via the interface. The write sequence is 
initiated when CSX is driven from high to low and ends when CSX is pulled high.
DCX is driven low while command information is on the interface and is pulled 
high when data is present.

When define TESTMODE_EN to 1 in nemadc_spi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemagfx_benchmarks


Description:
============
 NemaGFX example.


this example demonstrate the Nema GPU and CPU performance use Nema GPU's
basic characteristics, we should care about the FPS after each individual
test.
need a timer to get the accurate time past.

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_blend


Description:
============
 NemaGFX example.

brief Example that demonstrates blend feature
Blending requires a series of calculations between the source (foreground)
and destination (background)color fragments for producing the final color,
which will be written in memory.This example use a constent table inside
most of the supported blending mode.demonstrates each more every 1 second.
the dst color is nema_rgba(0xff, 0, 0, 0x80), which is red color with 50%
alpha blending, the src color is nema_rgba(0, 0, 0xff, 0x80), which is blue
color with 50% alpha blending.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 nemagfx_gauge


Description:
============
 Example of the app running under NemaGFX guage examples

of its GuiBuilder.

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_grad


Description:
============
 NemaGFX example.

In computer graphics, a color gradient specifies a range of position-dependent
colors, usually used to fill a region. For example, many window managers
allow the screen background to be specified as a gradient. The colors
produced by a gradient vary continuously with the position, producing smooth
color transitions.


******************************************************************************


Name:
=====
 nemagfx_rotating_clock


Description:
============
 NemaGFX example.

this example use two frame buffer demonstrate a digital rotating clock,
with Nema GPU support, the shader effect continue shows while timer passing
need a timer to get the accurate time past.


******************************************************************************


Name:
=====
 nemagfx_rotating_crate


Description:
============
 Example of the app running nemagfx rotating_crate.

this example shows a rotating crate with texture rending support. with Nema
GPU support, it can significantly reduce the general CPU effort to calculate
the data inside the frame buffer

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_transition_effects


Description:
============
 Example of the app running under NemaGFX guage examples

this example use one frame buffer demonstrate two picture trasition effect,
with Nema GPU support, the effect include
NEMA_TRANS_LINEAR_H,
NEMA_TRANS_CUBE_H,
NEMA_TRANS_INNERCUBE_H,
NEMA_TRANS_STACK_H,
NEMA_TRANS_LINEAR_V,
NEMA_TRANS_CUBE_V,
NEMA_TRANS_INNERCUBE_V,
NEMA_TRANS_STACK_V,
NEMA_TRANS_FADE,
NEMA_TRANS_FADE_ZOOM,
NEMA_TRANS_MAX,
NEMA_TRANS_NONE

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_tsc_fb


Description:
============
 NemaGFX example.

Nemagfx_tsc_fb is a demo of TSC frame-buffer compression. The program uses
TSC4-compressed frame-buffer during run-time. It saves frame-buffer space
in RAM in a scale of 1:4 also.The demo use example NEMADC_TSC4 frame buffer
shows a 400x400 TSC4 image on the screen, it will significantly save RAM use.
Note:  the width and height of the frame-buffer should be 4-pixels aligned

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_watchface


Description:
============
 NemaGFX example.

this example uses two frame buffer demonstrate a digital Quartz clock, with 
Nema GPU support, the shader effect continue shows while timer passing, the 
function needs a timer to get the accurate time past.
AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_watch_gui


Description:
============
 Example of the app running under NemaGFX watch_gui examples

of its GuiBuilder.
this problem is created by Nema guiBuilder, we simulated the touch event by
always touched and moving left to right and then right to left reciprocating.

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 ios_fifo


Description:
============
 Example slave used for demonstrating the use of the IOS FIFO.


Purpose:
========
This slave component runs on one EVB and is used in conjunction with
the companion host example, ios_fifo_host, which runs on a second EVB.

The ios_fifo example has no print output.
The host example does use the ITM SWO to let the user know progress and
status of the demonstration.

This example implements the slave part of a protocol for data exchange with
an Apollo IO Master (IOM).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgment to IOS once it has finished reading a block
of data initiated by IOS (partially or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
In order to run this example, a host device (e.g. a second EVB) must be set
up to run the host example, ios_fifo_host.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[6]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[7]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[50] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 ios_fifo_host


Description:
============
 Example host used for demonstrating the use of the IOS FIFO.


Purpose:
========
This host component runs on one EVB and is used in conjunction with
the companion slave example, ios_fifo, which runs on a second EVB.

The host example uses the ITM SWO to let the user know progress and
status of the demonstration.  The SWO is configured at 1M baud.
The ios_fifo example has no print output.

This example implements the host part of a protocol for data exchange with
an Apollo IO Slave (IOS).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgement to IOS once it has finished reading a block
of data initiated by IOS (partitally or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Additional Information:
=======================
In order to run this example, a slave device (e.g. a second EVB) must be set
up to run the companion example, ios_fifo.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[6]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[7]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[50] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 mspi_octal_example


Description:
============
 Example of the MSPI operation with Octal SPI Flash.


Purpose:
========
This example configures an MSPI connected flash device in Octal mode
and performs various operations - verifying the correctness of the same
Operations include - Erase, Write, Read, and XIP

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
this example can work on:
Apollo3p_evb + Cygnus
Target hardware uses 1.8V power supply voltage.
Actual Octal flash on Cygnus board is ATXP128 (Device ID: 0x00A91F) instead of ATXP032
Define ADESTO_ATXP032



******************************************************************************


Name:
=====
 mspi_quad_example


Description:
============
 Example of the MSPI operation with Quad SPI PSRAM.


Purpose:
========
This example demonstrates MSPI Quad operation using the MSPI PSRAM
device.



******************************************************************************


Name:
=====
 mspi_quad_example


Description:
============
 Example of the MSPI operation with Quad SPI Flash.


Purpose:
========
This example configures an MSPI connected flash device in Quad mode
and performs various operations - verifying the correctness of the same
Operations include - Erase, Write, Read, Read using XIP Apperture and XIP.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
this example can work on:
Apollo3p_evb + Cygnus
Target hardware uses 1.8V power supply voltage.



******************************************************************************


Name:
=====
 mram_program


Description:
============
 MRAM programming example.


Purpose:
========
This example shows how to modify the internal MRAM using HAL
MRAM helper functions.

This example works on the portion of the MRAM at the 1MB boundary.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 adc_lpmode0_dma


Description:
============
 This example takes samples with the ADC at high-speed using DMA.


Purpose:
========
This example shows the CTIMER-A3 triggering repeated samples of an external
input at 1.2Msps in LPMODE0.  The example uses the CTIMER-A3 to trigger
ADC sampling.  Each data point is 128 sample average and is transferred
from the ADC FIFO into an SRAM buffer using DMA.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 binary_counter


Description:
============
 Example that displays the timer count on the LEDs.


Purpose:
========
This example increments a variable on every timer interrupt. The global
variable is used to set the state of the LEDs. The example sleeps otherwise.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 hello_world


Description:
============
 A simple "Hello World" example.


This example prints a "Hello World" message with some device info
over SWO at 1M baud. To see the output of this program, run AMFlash,
and configure the console for SWO. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 rtc_print


Description:
============
 Example using the internal RTC.


This example demonstrates how to interface with the RTC and prints the
time over SWO.

The example works by configuring a timer interrupt which will periodically
wake the core from deep sleep. After every interrupt, it prints the current
RTC time.



******************************************************************************


Name:
=====
 stimer


Description:
============
 Example using a stimer with interrupts.


Purpose:
========
This example demonstrates how to setup the stimer for counting and
interrupts. It toggles LED 0 to 4 every interrupt, which is set for 1 sec.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 watchdog


Description:
============
 Example of a basic configuration of the watchdog.


Purpose:
========
This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_fit


Description:
============
 ARM Cordio BLE - Fit Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 coremark


Description:
============
 EEMBC COREMARK test.


Purpose:
========
This example runs the official EEMBC COREMARK test.

The Coremark run begins by first outputing a banner (to the UART)
indicating that it has started.  It then does a complete disable
and power down of the UART for accurate power measuring during the run.

The Coremkark implementation performs 2000 ITERATIONS (specified in
ambiq_core_config.h), which is plenty of time for correct operation
of the benchmark.

Once the run has completed, the UART is reenabled and the results printed.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep


Description:
============
 Example demonstrating how to enter deepsleep.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
sleep mode the device has no ability to wake up. This example is merely to
provide the opportunity to measure deepsleep current without interrupts
interfering with the measurement.

The example begins by printing out a banner announcement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep_wake


Description:
============
 Example that goes to deepsleep and wakes from either the RTC or GPIO.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
deep sleep the RTC peripheral will wake the device every second, check to
see if 5 seconds has elapsed and then toggle LED1.

Alternatively, it will awake when button 0 is pressed and toggle LED0.

The example begins by printing out a banner annoucement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


micro-ecc
==========

A small and fast ECDH and ECDSA implementation for 8-bit, 32-bit, and 64-bit processors.

The old version of micro-ecc can be found in the "old" branch.

Features
--------

 * Resistant to known side-channel attacks.
 * Written in C, with optional GCC inline assembly for AVR, ARM and Thumb platforms.
 * Supports 8, 32, and 64-bit architectures.
 * Small code size.
 * No dynamic memory allocation.
 * Support for 4 standard curves: secp160r1, secp192r1, secp256r1, and secp256k1.
 * BSD 2-clause license.

Usage Notes
-----------
### Point Representation ###
Compressed points are represented in the standard format as defined in http://www.secg.org/collateral/sec1_final.pdf; uncompressed points are represented in standard format, but without the `0x04` prefix. `uECC_make_key()`, `uECC_shared_secret()`, `uECC_sign()`, and `uECC_verify()` only handle uncompressed points; you can use `uECC_compress()` and `uECC_decompress()` to convert between compressed and uncompressed point representations.

Private keys are represented in the standard format.

### Using the Code ###

I recommend just copying (or symlink) uECC.h, uECC.c, and the appropriate asm\_&lt;arch&gt;\_.inc (if any) into your project. Then just `#include "uECC.h"` to use the micro-ecc functions.

For use with Arduino, you can just create a symlink to the `uECC` directory in your Arduino `libraries` directory. You can then use uECC just like any other Arduino library (uECC should show up in the **Sketch**=>**Import Library** submenu).

See uECC.h for documentation for each function.

### Compilation Notes ###

 * Should compile with any C/C++ compiler that supports stdint.h (this includes Visual Studio 2013).
 * If you want to change the defaults for `uECC_CURVE` and `uECC_ASM`, you must change them in your Makefile or similar so that uECC.c is compiled with the desired values (ie, compile uECC.c with `-DuECC_CURVE=uECC_secp256r1` or whatever).
 * When compiling for a Thumb-1 platform with inline assembly enabled (ie, `uECC_ASM` is defined to `uECC_asm_small` or `uECC_asm_fast`), you must use the `-fomit-frame-pointer` GCC option (this is enabled by default when compiling with `-O1` or higher).
 * When compiling for an ARM/Thumb-2 platform with fast inline assembly enabled (ie, `uECC_ASM` is defined to `uECC_asm_fast`), you must use the `-fomit-frame-pointer` GCC option (this is enabled by default when compiling with `-O1` or higher).
 * When compiling for AVR with inline assembly enabled, you must have optimizations enabled (compile with `-O1` or higher).
 * When building for Windows, you will need to link in the `advapi32.lib` system library.

ARM Performance
---------------

All tests were built using gcc 4.8.2 with `-O3`, and were run on a Raspberry Pi B+. `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases. All times are in milliseconds.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH:</em></td>
		<td>2.3</td>
		<td>2.7</td>
		<td>7.9</td>
		<td>6.5</td>
	</tr>
	<tr>
		<td><em>ECDSA sign:</em></td>
		<td>2.8</td>
		<td>3.1</td>
		<td>8.6</td>
		<td>7.2</td>
	</tr>
	<tr>
		<td><em>ECDSA verify:</em></td>
		<td>2.7</td>
		<td>3.2</td>
		<td>9.2</td>
		<td>7.0</td>
	</tr>
</table>

AVR Performance
---------------

All tests were built using avr-gcc 4.8.1 with `-Os`, and were run on a 16 MHz ATmega256RFR2. Code size refers to the space used by micro-ecc code and data.

#### ECDH (fast) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH time (ms):</em></td>
		<td>470</td>
		<td>810</td>
		<td>2220</td>
		<td>1615</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>10768</td>
		<td>13112</td>
		<td>20886</td>
		<td>21126</td>
	</tr>
</table>

#### ECDH (small) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_small` and `ECC_SQUARE_FUNC` was defined to `0` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH time (ms):</em></td>
		<td>1250</td>
		<td>1810</td>
		<td>4790</td>
		<td>4700</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>3244</td>
		<td>3400</td>
		<td>5274</td>
		<td>3426</td>
	</tr>
</table>

#### ECDSA (fast) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDSA sign time (ms):</em></td>
		<td>555</td>
		<td>902</td>
		<td>2386</td>
		<td>1773</td>
	</tr>
	<tr>
		<td><em>ECDSA verify time (ms):</em></td>
		<td>590</td>
		<td>990</td>
		<td>2650</td>
		<td>1800</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>13246</td>
		<td>14798</td>
		<td>22594</td>
		<td>22826</td>
	</tr>
</table>

#### ECDSA (small) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_small` and `ECC_SQUARE_FUNC` was defined to `0` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDSA sign time (ms):</em></td>
		<td>1359</td>
		<td>1931</td>
		<td>4998</td>
		<td>4904</td>
	</tr>
	<tr>
		<td><em>ECDSA verify time (ms):</em></td>
		<td>1515</td>
		<td>2160</td>
		<td>5700</td>
		<td>5220</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>5690</td>
		<td>5054</td>
		<td>6980</td>
		<td>5080</td>
	</tr>
</table>
